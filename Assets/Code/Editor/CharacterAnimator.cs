using UnityEngine;
using UnityEditor;
using UnityEditor.Animations;
using System.Collections;
using System.Collections.Generic;


public class CharacterAnimator {

	[System.Serializable]
	public class SMWAnimation
	{
		public string name;
		public int framesPerSecond;	 // sample			// 2013.12.16 Live Training 16 Dec 2013 - 2D Character Controllers (720p).mp4  @@ 26:14
		public int keyFrames;
		public int frameDistance;
		public Sprite[] sprites;
		public WrapMode wrapMode;
		public AnimatorState animState;
		
		public SMWAnimation(string name, int framesPerSecond, int keyFrames, Sprite[] sprites, WrapMode wrapMode, AnimatorState animState)
		{
			this.name = name;
			this.wrapMode = wrapMode;
			this.framesPerSecond = framesPerSecond;
			this.keyFrames = keyFrames;
			this.animState = animState;
			this.sprites = sprites;
		}
	}

	public static List<SMWAnimation> smwAnimations = new List<SMWAnimation>();	// = new SMWAnimation[6];

	public static RuntimeAnimatorController Create (SmwCharacterGenerics smwCharacterGenerics, SmwCharacter smwCharacter, Teams teamId)
	{
		string charName = smwCharacter.charName;
		if(charName == "")
		{
			Debug.LogError("smwCharacter hat keinen namen gesetzt!");
			charName = "unnamedChar";
		}
		Debug.Log( "CharacterAnimator" + " Create ()" + charName);
		
		string createdCharacterFolderPath = "Animations/Characters/AutoGenerated/"+charName+"_"+teamId ;
		if(!CreateFolder(createdCharacterFolderPath))
		{
			Debug.LogError("Ordner existiert/existerieren nicht und kann/können nicht angelegt werden!\n" + createdCharacterFolderPath);
			return null;
		}
		
		/**
		 * 			AssetDatabase :	All paths are relative to the project folder => paths always = "Assets/..../..." //TODO last folder no SLASH / !!!
		 **/
		
		
		//		string assetCreatedCharacterFolderPath = "Assets/" + createdCharacterFolderPath;
		UnityEditor.Animations.AnimatorController controller =  UnityEditor.Animations.AnimatorController.CreateAnimatorControllerAtPath( "Assets/" + createdCharacterFolderPath + "/" + charName + "_" + teamId + "_scripted_AnimatorController.controller");
		
		// Add parameters
		controller.AddParameter(HashID.p_hSpeed, AnimatorControllerParameterType.Float);
		controller.AddParameter(HashID.p_vSpeed, AnimatorControllerParameterType.Float);
		controller.AddParameter(HashID.p_grounded, AnimatorControllerParameterType.Bool);
		controller.AddParameter(HashID.p_walled, AnimatorControllerParameterType.Bool);
		controller.AddParameter(HashID.p_changeRunDirectionTrigger, AnimatorControllerParameterType.Trigger);
		
		controller.AddParameter(HashID.p_hitTrigger, AnimatorControllerParameterType.Trigger);
		controller.AddParameter(HashID.p_nextStateTrigger, AnimatorControllerParameterType.Trigger);
		controller.AddParameter(HashID.p_hitted, AnimatorControllerParameterType.Bool);
		controller.AddParameter(HashID.p_gameOver, AnimatorControllerParameterType.Bool);
		controller.AddParameter(HashID.p_headJumped, AnimatorControllerParameterType.Bool);
		controller.AddParameter(HashID.p_dead, AnimatorControllerParameterType.Bool);
		
		controller.AddParameter(HashID.p_spawn, AnimatorControllerParameterType.Bool);
		controller.AddParameter(HashID.p_Protection, AnimatorControllerParameterType.Bool);
		controller.AddParameter(HashID.p_startProtectionTrigger, AnimatorControllerParameterType.Trigger);
		controller.AddParameter(HashID.p_stopProtectionTrigger, AnimatorControllerParameterType.Trigger);
		
		controller.AddParameter(HashID.p_rageTrigger, AnimatorControllerParameterType.Trigger);
		controller.AddParameter(HashID.p_rageModusBool, AnimatorControllerParameterType.Bool);
		
		// Layer 0 State Machine
		AnimatorStateMachine rootStateMachine = controller.layers[0].stateMachine;

        Vector3 anyStatePos = rootStateMachine.anyStatePosition;
        Vector3 entryStatePos = rootStateMachine.entryPosition;
        Vector3 refStatePos = anyStatePos;
        Vector3 tempStatePos;

        tempStatePos = anyStatePos;
        tempStatePos.x += 200;
        rootStateMachine.anyStatePosition = tempStatePos;

        /*          Add states           */

        tempStatePos.x = refStatePos.x + 200;
        tempStatePos.y = refStatePos.y - 200;
		AnimatorState idleState = controller.layers[0].stateMachine.AddState(HashID.s_Idle, tempStatePos);
        //		idleState.motion = idleAnim;

        tempStatePos.x = refStatePos.x + 200;
        tempStatePos.y = refStatePos.y - 100;
        AnimatorState jumpState = controller.layers[0].stateMachine.AddState(HashID.s_JumpAndFall, tempStatePos);
        //		jumpState.motion = jumpAnim;

        tempStatePos.x = refStatePos.x + 200;
        tempStatePos.y = refStatePos.y - 300;
        AnimatorState runState = controller.layers[0].stateMachine.AddState(HashID.s_Run, tempStatePos);
        //		runState.motion = runAnim;

        tempStatePos.x = refStatePos.x + 200;
        tempStatePos.y = refStatePos.y - 400;
        AnimatorState skidState = controller.layers[0].stateMachine.AddState(HashID.s_ChangeRunDirection, tempStatePos);
        //		skidState.motion = changeRunDirectionAnim;

        tempStatePos.x = refStatePos.x + 600;
        tempStatePos.y = refStatePos.y;
        AnimatorState hittedState = controller.layers[0].stateMachine.AddState(HashID.s_Generic_Hitted, tempStatePos);
        //		hittedState.motion = idleAnim;

        tempStatePos.x = refStatePos.x + 750;
        tempStatePos.y = refStatePos.y - 100;
        AnimatorState headJumpedState = controller.layers[0].stateMachine.AddState(HashID.s_HeadJumped, tempStatePos);
        //		headJumpedState.motion = headJumpedAnim;

        tempStatePos.x = refStatePos.x + 450;
        tempStatePos.y = refStatePos.y - 100;
        AnimatorState gameOverState = controller.layers[0].stateMachine.AddState(HashID.s_GameOver, tempStatePos);
        //		gameOverState.motion = headJumpedAnim;

        tempStatePos.x = refStatePos.x + 600;
        tempStatePos.y = refStatePos.y - 200;
        AnimatorState deadState = controller.layers[0].stateMachine.AddState(HashID.s_Dead, tempStatePos);
        //		deadState.motion = headJumpedAnim;

        tempStatePos.x = refStatePos.x + 750;
        tempStatePos.y = refStatePos.y - 300;
        AnimatorState spawnState = controller.layers[0].stateMachine.AddState(HashID.s_Generic_Spawn, tempStatePos);
		spawnState.AddStateMachineBehaviour(typeof(SpawnStateScript));  //TODO reference zu characterScript direct mitgeben???
                                                                        //		spawnState.AddStateMachineBehaviour(new SpawnStateScript());

        tempStatePos.x = refStatePos.x + 800;
        tempStatePos.y = refStatePos.y - 400;
        AnimatorState spawnDelayState = controller.layers[0].stateMachine.AddState(HashID.s_Generic_SpawnDelay, tempStatePos);
		spawnDelayState.AddStateMachineBehaviour(typeof(SpawnDelayStateScript));	//TODO reference zu characterScript direct mitgeben???
//		spawnState.AddStateMachineBehaviour(new SpawnDelayStateScript());

		//		spawnState.motion = headJumpedAnim;
		
//		AnimatorState spawnProtectionState = controller.layers[0].stateMachine.AddState(HashID.s_Generic_SpawnProtection);
		//		spawnProtectionState.motion = headJumpedAnim;
		
		
		/**
		 * Layer 1 - Overlay Layer
		 **/

		// FIX defaultWeight and blendingMode!!!!
//		// Manual Creating Layer : http://forum.unity3d.com/threads/animatorcontroller-addlayer-doesnt-create-default-animatorstatemachine.307873/#post-2003218
		AnimatorControllerLayer newLayer = new AnimatorControllerLayer();
		newLayer.name = HashID.l_overlay;
		newLayer.stateMachine = new AnimatorStateMachine();
		newLayer.stateMachine.name = newLayer.name;
		newLayer.stateMachine.hideFlags = HideFlags.HideInHierarchy;
		if (AssetDatabase.GetAssetPath(controller) != "")
			AssetDatabase.AddObjectToAsset(newLayer.stateMachine, AssetDatabase.GetAssetPath(controller));
		//Custom
		newLayer.blendingMode = AnimatorLayerBlendingMode.Override;
		newLayer.defaultWeight = 1f;
		controller.AddLayer(newLayer);


		// Another Way:
		//Animator anim;
		//anim.SetLayerWeight (layerIndex, weight)

//		// Auto Creating Layer & StateMachine  AddLayer(string)!!!
//		controller.AddLayer(HashID.l_overlay);
//		controller.layers[1].blendingMode = AnimatorLayerBlendingMode.Additive;			// setzt für die zeit die es aktiv ist die variablen und wenn deaktiviert wird variable auf vorherigen wert gesetzt
//		controller.layers[1].defaultWeight = 1f;

		if(controller.layers[1].stateMachine == null)
		{
			Debug.LogError("stateMachine == null");
//			controller.layers[1].stateMachine = new AnimatorStateMachine();
		}


		// Layer 1 State Machine
//		controller.layers[1].blendingMode = AnimatorLayerBlendingMode.Override;			// setzt für die zeit die es aktiv ist die variablen und wenn deaktiviert wird variable auf vorherigen wert gesetzt
//		controller.layers[1].defaultWeight = 1f;
		AnimatorStateMachine overlayStateMachine = controller.layers[1].stateMachine;

        refStatePos = overlayStateMachine.anyStatePosition;
        tempStatePos.x = refStatePos.x + 200;
        tempStatePos.y = refStatePos.y;
        AnimatorState defaultOverlayState = overlayStateMachine.AddState(HashID.s_l1_Generic_DefaultState, tempStatePos);

        tempStatePos.x = refStatePos.x + 200;
        tempStatePos.y = refStatePos.y - 100;
        AnimatorState invincibleOverlayState = overlayStateMachine.AddState(HashID.s_l1_Generic_Invincible, tempStatePos);

        tempStatePos.x = refStatePos.x + 200;
        tempStatePos.y = refStatePos.y + 100;
        AnimatorState protectionOverlayState = overlayStateMachine.AddState(HashID.s_l1_Generic_Protection, tempStatePos);
		
		AnimatorStateTransition leaveInvincibleEnterDefaultState = invincibleOverlayState.AddTransition(defaultOverlayState);
		//		leaveInvincibleEnterDefaultState.AddCondition(AnimatorConditionMode.If, 0, HashID.p_rageTrigger);
		leaveInvincibleEnterDefaultState.duration = 0;
		leaveInvincibleEnterDefaultState.hasExitTime = true;				//TODO achtung byTime!
		leaveInvincibleEnterDefaultState.exitTime = 1f;
		leaveInvincibleEnterDefaultState.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveProtectionEnterDefaultStateByTime = protectionOverlayState.AddTransition(defaultOverlayState);
		//		leaveInvincibleEnterDefaultState.AddCondition(AnimatorConditionMode.If, 0, HashID.p_rageTrigger);
		leaveProtectionEnterDefaultStateByTime.duration = 0;
		leaveProtectionEnterDefaultStateByTime.hasExitTime = true;			//TODO achtung byTime!
		leaveProtectionEnterDefaultStateByTime.exitTime = 1f;
		leaveProtectionEnterDefaultStateByTime.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveProtectionEnterDefaultStateByTrigger = protectionOverlayState.AddTransition(defaultOverlayState);
		leaveProtectionEnterDefaultStateByTrigger.AddCondition(AnimatorConditionMode.If, 0, HashID.p_stopProtectionTrigger);				//TODO defaultOverlayState muss kräfte invincible/spawnprotection entfernen??
		leaveProtectionEnterDefaultStateByTrigger.duration = 0;
		leaveProtectionEnterDefaultStateByTrigger.hasExitTime = false;
		leaveProtectionEnterDefaultStateByTrigger.exitTime = 1f;
		leaveProtectionEnterDefaultStateByTrigger.canTransitionToSelf = false;
		
		// Overlay Layer : AnyState Transitions to InvincibleState
		AnimatorStateTransition enterInvincibleOverlayerState = overlayStateMachine.AddAnyStateTransition(invincibleOverlayState);
		enterInvincibleOverlayerState.AddCondition(AnimatorConditionMode.If, 0, HashID.p_rageTrigger);
		enterInvincibleOverlayerState.duration = 0;
		enterInvincibleOverlayerState.hasExitTime = false;
		enterInvincibleOverlayerState.exitTime = 1f;
		enterInvincibleOverlayerState.canTransitionToSelf = false;
		
		
		// Overlay Layer : AnyState Transitions to ProtectionState
		AnimatorStateTransition enterProtectionOverlayerState = overlayStateMachine.AddAnyStateTransition(protectionOverlayState);	//TODO rename SpawnProtection to Protection
		enterProtectionOverlayerState.AddCondition(AnimatorConditionMode.If, 0, HashID.p_startProtectionTrigger);
		enterProtectionOverlayerState.duration = 0;
		enterProtectionOverlayerState.hasExitTime = false;
		enterProtectionOverlayerState.exitTime = 1f;
		enterProtectionOverlayerState.canTransitionToSelf = false;
		
		
		
		// State Transition Setup
		
		// Layer 0 - Base Layer
		
		float minHorizontalSpeed = 0.01f;	// setze schwellwert (treshold)
		
		AnimatorStateTransition leaveIdleEnterRunIfGreater = idleState.AddTransition(runState);
		leaveIdleEnterRunIfGreater.AddCondition(AnimatorConditionMode.Greater, minHorizontalSpeed, HashID.p_hSpeed);
		leaveIdleEnterRunIfGreater.duration = 0;
		leaveIdleEnterRunIfGreater.hasExitTime = false;
		leaveIdleEnterRunIfGreater.exitTime = 1f;
		leaveIdleEnterRunIfGreater.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveIdleEnterRunIfLower = idleState.AddTransition(runState);
		leaveIdleEnterRunIfLower.AddCondition(AnimatorConditionMode.Less, -minHorizontalSpeed, HashID.p_hSpeed);
		leaveIdleEnterRunIfLower.duration = 0;
		leaveIdleEnterRunIfLower.hasExitTime = false;
		leaveIdleEnterRunIfLower.exitTime = 1f;
		leaveIdleEnterRunIfLower.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveRunEnterIdle = runState.AddTransition(idleState);
		leaveRunEnterIdle.AddCondition(AnimatorConditionMode.Greater, -minHorizontalSpeed, HashID.p_hSpeed);
		leaveRunEnterIdle.AddCondition(AnimatorConditionMode.Less, minHorizontalSpeed, HashID.p_hSpeed);
		leaveRunEnterIdle.duration = 0;
		leaveRunEnterIdle.hasExitTime = false;
		leaveRunEnterIdle.exitTime = 1f;
		leaveRunEnterIdle.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveIdleEnterJump = idleState.AddTransition(jumpState);
		leaveIdleEnterJump.AddCondition(AnimatorConditionMode.IfNot, 0, HashID.p_grounded);
		leaveIdleEnterJump.duration = 0;
		leaveIdleEnterJump.hasExitTime = false;
		leaveIdleEnterJump.exitTime = 1f;
		leaveIdleEnterJump.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveJumpEnterIdle = jumpState.AddTransition(idleState);
		leaveJumpEnterIdle.AddCondition(AnimatorConditionMode.If, 0, HashID.p_grounded);
		leaveJumpEnterIdle.duration = 0;
		leaveJumpEnterIdle.hasExitTime = false;
		leaveJumpEnterIdle.exitTime = 1f;
		leaveJumpEnterIdle.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveRunEnterSkid = runState.AddTransition(skidState);
		leaveRunEnterSkid.AddCondition(AnimatorConditionMode.If, 0, HashID.p_changeRunDirectionTrigger);
		leaveRunEnterSkid.duration = 0;
		leaveRunEnterSkid.hasExitTime = false;
		leaveRunEnterSkid.exitTime = 1f;
		leaveRunEnterSkid.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveSkidEnterRun = skidState.AddTransition(runState);
		//leaveSkidEnterRun.AddCondition(AnimatorConditionMode.If, 0, HashID.p_changeRunDirectionTrigger);
		leaveSkidEnterRun.duration = 0;
		leaveSkidEnterRun.hasExitTime = true;			//TODO achtung byTime!
		leaveSkidEnterRun.exitTime = 1f;
		leaveSkidEnterRun.canTransitionToSelf = false;

        // Any State Transistion
        AnimatorStateTransition fallingTransition = rootStateMachine.AddAnyStateTransition(jumpState); //special TODO markt
        fallingTransition.AddCondition(AnimatorConditionMode.If, 0, HashID.p_hitTrigger);
        fallingTransition.duration = 0;
        fallingTransition.hasExitTime = false;
        fallingTransition.exitTime = 1f;
        fallingTransition.canTransitionToSelf = false;

        // Any State Transistion
        AnimatorStateTransition hittedTransition = rootStateMachine.AddAnyStateTransition(hittedState);	//special TODO markt
		hittedTransition.AddCondition(AnimatorConditionMode.If, 0, HashID.p_hitTrigger);
		hittedTransition.duration = 0;
		hittedTransition.hasExitTime = false;
		hittedTransition.exitTime = 1f;
		hittedTransition.canTransitionToSelf = false;
		
		
		AnimatorStateTransition leaveHittedEnterHeadJumped = hittedState.AddTransition(headJumpedState);
		leaveHittedEnterHeadJumped.AddCondition(AnimatorConditionMode.If, 0, HashID.p_headJumped);		// TODO <-- change to Trigger? p_headJumpedTrigger
		leaveHittedEnterHeadJumped.duration = 0;
		leaveHittedEnterHeadJumped.hasExitTime = false;
		leaveHittedEnterHeadJumped.exitTime = 1f;
		leaveHittedEnterHeadJumped.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveHittedEnterDie = hittedState.AddTransition(deadState);
		leaveHittedEnterDie.AddCondition(AnimatorConditionMode.If, 0, HashID.p_dead);		// TODO <-- change to name p_dieTrigger
		leaveHittedEnterDie.duration = 0;
		leaveHittedEnterDie.hasExitTime = false;
		leaveHittedEnterDie.exitTime = 1f;
		leaveHittedEnterDie.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveHittedEnterGameOver = hittedState.AddTransition(gameOverState);
		leaveHittedEnterGameOver.AddCondition(AnimatorConditionMode.If, 0, HashID.p_gameOver);		// TODO <-- change to name p_gameOverTrigger
		leaveHittedEnterGameOver.duration = 0;
		leaveHittedEnterGameOver.hasExitTime = false;
		leaveHittedEnterGameOver.exitTime = 1f;
		leaveHittedEnterGameOver.canTransitionToSelf = false;
		
		
		AnimatorStateTransition leaveHeadJumpedEnterSpawn = headJumpedState.AddTransition(spawnState);
		leaveHeadJumpedEnterSpawn.AddCondition(AnimatorConditionMode.If, 0, HashID.p_spawn);		// TODO <-- change to name p_spawnTrigger
		leaveHeadJumpedEnterSpawn.duration = 0;
		leaveHeadJumpedEnterSpawn.hasExitTime = false;
		leaveHeadJumpedEnterSpawn.exitTime = 1f;
		leaveHeadJumpedEnterSpawn.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveDieEnterSpawn = deadState.AddTransition(spawnState);
		leaveDieEnterSpawn.AddCondition(AnimatorConditionMode.If, 0, HashID.p_spawn);		// TODO <-- change to name p_spawnTrigger
		leaveDieEnterSpawn.duration = 0;
		leaveDieEnterSpawn.hasExitTime = false;
		leaveDieEnterSpawn.exitTime = 1f;
		leaveDieEnterSpawn.canTransitionToSelf = false;
		
		AnimatorStateTransition leaveSpawnEnterIdle = spawnState.AddTransition(idleState);
		//leaveSpawnEnterIdle.AddCondition(AnimatorConditionMode.If, 0, HashID.p_spawn);		//TODO add condition to enable controlls & enable gravity & & ...
		leaveSpawnEnterIdle.duration = 0;
		leaveSpawnEnterIdle.hasExitTime = true;				//TODO achtung byTime!	//TODO <-- Achtung 	hasExitTime (nach Animation)
		leaveSpawnEnterIdle.exitTime = 1f;
		leaveSpawnEnterIdle.canTransitionToSelf = false;
		
		
		
		// init smwAnimations array
		
//		int baseLayerStateCount = 0;
		smwAnimations.Clear();		// BUG FIX!
		smwAnimations.Add(new SMWAnimation(charName + "_" + teamId + "_dynamic_Idle",		    24,1,	smwCharacter.GetSprites(teamId, SmwCharacterAnimation.Idle),	    WrapMode.Loop,	idleState));
		smwAnimations.Add(new SMWAnimation(charName + "_" + teamId + "_dynamic_Run",			24,2,   smwCharacter.GetSprites(teamId, SmwCharacterAnimation.Run),	        WrapMode.Loop,	runState));
		smwAnimations.Add(new SMWAnimation(charName + "_" + teamId + "_dynamic_Jump",		    24,1,	smwCharacter.GetSprites(teamId, SmwCharacterAnimation.Jump),	    WrapMode.Loop,	jumpState));
		smwAnimations.Add(new SMWAnimation(charName + "_" + teamId + "_dynamic_Skid",		    24,1,	smwCharacter.GetSprites(teamId, SmwCharacterAnimation.Skid),	    WrapMode.Loop,	skidState));
		smwAnimations.Add(new SMWAnimation(charName + "_" + teamId + "_dynamic_Die",			24,1,	smwCharacter.GetSprites(teamId, SmwCharacterAnimation.Die),	        WrapMode.Loop,	deadState));
		smwAnimations.Add(new SMWAnimation(charName + "_" + teamId + "_dynamic_HeadJumped",	    24,1,	smwCharacter.GetSprites(teamId, SmwCharacterAnimation.HeadJumped),	WrapMode.Loop,	headJumpedState));

		

		for(int i=0; i < smwAnimations.Count; i++)
		{
			// AnimationClip
			AnimationClip tempAnimClip = new AnimationClip();
			#if !UNITY_5
			// Setting it as generic allows you to use the animation clip in the animation controller
			AnimationUtility.SetAnimationType(tempAnimClip, ModelImporterAnimationType.Generic);
			#endif
			tempAnimClip.name = smwAnimations[i].name;

			// Frames Per Second //TODO ACHTUNG: 
			tempAnimClip.frameRate = smwAnimations[i].framesPerSecond;

			// LOOP
//			Debug.Log( "before loopTime = " + AnimationUtility.GetAnimationClipSettings(tempAnimClip).loopTime);
//			AnimationUtility.GetAnimationClipSettings(tempAnimClip).loopTime = true;
//			Debug.Log( "after loopTime = " + AnimationUtility.GetAnimationClipSettings(tempAnimClip).loopTime);
			
			// LOOP WORKS
//			Debug.Log( "before serializedClip loopTime = " + AnimationUtility.GetAnimationClipSettings(tempAnimClip).loopTime);
			SerializedObject serializedClip = new SerializedObject(tempAnimClip);
			AnimationClipSettings clipSettings = new AnimationClipSettings(serializedClip.FindProperty("m_AnimationClipSettings"));
			clipSettings.loopTime = true;
			serializedClip.ApplyModifiedProperties();
//			Debug.Log( "after serializedClip loopTime = " + AnimationUtility.GetAnimationClipSettings(tempAnimClip).loopTime);
			

			// Wrap Mode (Loop, Once, PingPong....)
			tempAnimClip.wrapMode = smwAnimations[i].wrapMode;
			//tempAnimClip.

			// Setup EditorCurveBinding of Animation Clip
//			CreateAnimationClip(tempAnimClip, smwAnimations[i].sprites, smwAnimations[i].keyFrames, 1.0f/smwAnimations[i].framesPerSecond);
			CreateAnimationClip(tempAnimClip, smwAnimations[i]);

			// Add AnimationClip to State of StateMachine
			smwAnimations[i].animState.motion = tempAnimClip;
			
			// In order to insure better interpolation of quaternions, call this function after you are finished setting animation curves.
			tempAnimClip.EnsureQuaternionContinuity();

			if (AssetDatabase.Contains(tempAnimClip))
			{
				Debug.LogError(tempAnimClip.name + " in AssetDatabase bereits enthalten, darf nicht erscheinen");
			}
			else
			{
				//					Debug.Log(tempAnimClip.name + " nicht in AssetDatabase vorhanden, wird jetzt gespeichert.");
				
				// asset anlegen
				//					Debug.Log("Versuche " + tempAnimClip.name + " in Ordner " + "Assets/"+createdCharacterFolderPath + " zu speicheren");
				AssetDatabase.CreateAsset(tempAnimClip, "Assets/"+createdCharacterFolderPath + "/" + tempAnimClip.name + ".asset");
			}
		}
		AssetDatabase.SaveAssets();

		//TODO:: add Generic AnimationClips to characterAnimatorController
		spawnState.motion = smwCharacterGenerics.spawnAnimClip;
		protectionOverlayState.motion = smwCharacterGenerics.protectionAnimClip;
		invincibleOverlayState.motion = smwCharacterGenerics.rageAnimClip;
		//TODO

		//smwCharacter.runtimeAnimatorController = controller;
		smwCharacter.SetRuntimeAnimationController (teamId, controller);
		EditorUtility.SetDirty(smwCharacter);					// save ScriptableObject
		return controller;
	}

	static void CreateAnimationClip(AnimationClip animClip, SMWAnimation animSettings )
	{
		Sprite[] sprites = animSettings.sprites;
		int animationLength = animSettings.keyFrames;
		float singleFrameTime = 1.0f / animSettings.framesPerSecond;
//		Debug.Log("Create Animation: " + animClip.name + " " + " Spritearray = " + sprites.Length + ", Animation length = " + animationLength + ", single frame time = " + singleFrameTime );
		// First you need to create e Editor Curve Binding
		EditorCurveBinding curveBinding = new EditorCurveBinding();
		
		// I want to change the sprites of the sprite renderer, so I put the typeof(SpriteRenderer) as the binding type.
		curveBinding.type = typeof(SpriteRenderer);
		// Regular path to the gameobject that will be changed (empty string means root)
		curveBinding.path = "";
		// This is the property name to change the sprite of a sprite renderer
		curveBinding.propertyName = "m_Sprite";

//		curveBinding.propertyName = "

		// An array to hold the object keyframes
		ObjectReferenceKeyframe[] keyFrames = new ObjectReferenceKeyframe[animationLength];
		
		for (int i = 0; i < sprites.Length; i++)
		{
			keyFrames[i] = new ObjectReferenceKeyframe();
			// set the time
			keyFrames[i].time = i*singleFrameTime;			// TODO important
			// set reference for the sprite you want
			keyFrames[i].value = sprites[i];
			
		}
		
		AnimationUtility.SetObjectReferenceCurve(animClip, curveBinding, keyFrames);
	}

	
	/// <summary>
	/// Creates the folder.
	/// </summary>
	/// <returns><c>true</c>, if folder was created, <c>false</c> otherwise.</returns>
	/// <param name="pathRelativeToAssetsPath">Path relative to assets path. eg. Prefabs/Characters/Mario</param>
	public static bool CreateFolder( string pathRelativeToAssetsPath )
	{
		string[] pathSegments = pathRelativeToAssetsPath.Split( new char[] {'/'});
		string accumulatedUnityFolder = "Assets";					// Startwert
		string accumulatedSystemFolder = Application.dataPath;		// Startwert C:/Users/Aryan/Documents/SuperMarioWars_UnityNetwork/Assets
		
		//		Debug.Log("Unity : " + accumulatedUnityFolder);
		//		Debug.Log("System: " + accumulatedSystemFolder);
		
		string lastExistedFolder = accumulatedUnityFolder;
		
		foreach( string folder in pathSegments )
		{
			accumulatedSystemFolder +=  "/" + folder;
			accumulatedUnityFolder += "/" + folder;
			
			string guidFolder = "";
			if (!System.IO.Directory.Exists(accumulatedSystemFolder))
			{
				Debug.LogWarning (accumulatedSystemFolder + " Ordner existiert nicht!\n" + 
				                  accumulatedUnityFolder + " Ordner existiert nicht!");
				
				Debug.Log("parentFolder = " + lastExistedFolder + " (letzter existierender Ordner)");
				string guidParentFolder =  AssetDatabase.AssetPathToGUID(lastExistedFolder);
				if( guidParentFolder != "" )
				{
					Debug.Log("guidParentFolder = " + guidParentFolder);
					guidFolder = AssetDatabase.CreateFolder( lastExistedFolder, folder );							// TODO  ------------ WTF ordnerangabe geht!  GUID angabe geht nicht!!!!
					if( guidFolder != "" )
					{
						Debug.Log (accumulatedSystemFolder + " Ordner wurder erfolgreich erstellt! \n" +
						           accumulatedUnityFolder + " Ordner wurder erfolgreich erstellt! \n");
					}
					else
					{
						Debug.LogError ( "Ordner " + folder + " konnte in " + lastExistedFolder + " nicht erstellt werden!");
						//						Debug.LogError (accumulatedSystemFolder + " konnte nicht erstellt werden! \n" +
						//						                accumulatedUnityFolder + " konnte nicht erstellt werden! \n");
						return false;
					}
				}
				else
				{
					Debug.LogError (accumulatedSystemFolder + " guidParentFolder konnte nicht gefunden werden! \n" +
					                accumulatedUnityFolder + " guidParentFolder konnte nicht gefunden werden! \n");
					return false;
				}
			}
			else
			{
				//				Debug.Log (accumulatedSystemFolder + " existiert! \n" +
				//				           accumulatedUnityFolder + " existiert!");
			}
			
			lastExistedFolder = accumulatedUnityFolder;
		}
		return true;
	}

}
